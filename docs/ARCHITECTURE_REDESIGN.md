# 텅장히어로 아키텍처 재설계

## 1. 현재 상황 분석

### 1.1 기존 아키텍처 (온라인 전용)

```
Flutter App
    ↓
REST API (Go 서버)
    ↓
PostgreSQL
```

**문제점:**
- 모든 데이터가 서버에만 저장됨
- 인터넷 필수 (온라인 전용)
- 거래 기록 도중 인터넷 끊김 → 데이터 손실 위험
- 서버 부하 높음 (모든 CRUD 작업 처리)
- 응답 속도 느림 (네트워크 왕복)
- 가계부 앱으로서 실용성 낮음

### 1.2 프로젝트 특성

```
텅장히어로 = 가계부 + RPG 게임
```

**가계부 특성:**
- 언제 어디서나 지출 기록 필수
- 인터넷 없는 상황 빈번 (대중교통, 오프라인 매장)
- 개인 재정 데이터 (프라이빗)
- → **오프라인 지원 필수**

**RPG 게임 특성:**
- 자동사냥 (시간 기반 보상)
- 히어로 레벨/경험치 (개인 진행도)
- 챌린지/랭킹 (다중 사용자 경쟁)
- 부정행위 방지 중요
- → **온라인 전용이 적합**

---

## 2. 제안: 하이브리드 아키텍처

### 2.1 핵심 원칙

```
┌─────────────────────────────────────────────────────────────┐
│                      텅장히어로                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [가계부]                         [게임]                   │
│   ├─ 오프라인 완전 지원             ├─ 온라인 전용           │
│   ├─ 로컬 SQLite 저장              ├─ 서버에서 처리          │
│   ├─ 온라인 시 백업/동기화          ├─ 부정행위 원천 차단     │
│   └─ 로그인 없어도 사용 가능        └─ 로그인 필수           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 새로운 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    Flutter App                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [로컬 SQLite - Drift]              [서버 통신 - Dio]      │
│   ├─ 거래 기록                       ├─ 게임 전체            │
│   ├─ 카테고리/태그                   │   ├─ 히어로/스탯       │
│   └─ 사용자 설정                     │   ├─ 인벤토리/장비     │
│                                      │   ├─ 자동사냥         │
│                                      │   └─ 챌린지/업적      │
│                                      ├─ 인증 (Google OAuth)  │
│                                      └─ 가계부 백업/동기화   │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                    Go 서버 (Gin)                            │
├─────────────────────────────────────────────────────────────┤
│ ✅ 인증 (로그인/회원가입, Google OAuth)                      │
│ ✅ 게임 로직 전체 (히어로, 인벤토리, 자동사냥, 챌린지)         │
│ ✅ 가계부 백업/동기화                                        │
│ ✅ 보상 지급 (거래 기록 → 게임 보상)                         │
│ ✅ FCM 푸시 알림                                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
                         PostgreSQL
```

### 2.3 데이터 분류

| 데이터 | 저장소 | 오프라인 접근 | 비고 |
|--------|--------|--------------|------|
| **거래 기록** | 로컬 SQLite | ✅ | 온라인 시 서버 백업 |
| **카테고리/태그** | 로컬 SQLite | ✅ | |
| **사용자 설정** | 로컬 SQLite | ✅ | |
| **히어로/스탯** | 서버 | ❌ | 온라인 전용 |
| **인벤토리/장비** | 서버 | ❌ | 온라인 전용 |
| **자동사냥** | 서버 | ❌ | 온라인 전용 |
| **챌린지/업적** | 서버 | ❌ | 온라인 전용 |
| **사용자 계정** | 서버 | ❌ | |

---

## 3. 핵심 설계

### 3.1 인증과 데이터 접근 분리

**핵심 원칙:**
```
┌─────────────────────────────────────────────────────────────┐
│  로그인 ≠ 앱 사용 권한                                       │
│  로그인 = 동기화/백업/게임 활성화                             │
├─────────────────────────────────────────────────────────────┤
│  토큰 만료되어도 로컬 가계부는 자유롭게 사용                   │
│  온라인 복귀 시 재로그인 → 동기화/게임 재개                   │
└─────────────────────────────────────────────────────────────┘
```

**앱 실행 플로우:**
```
앱 실행
    ↓
로컬 데이터 있음? ──Yes──→ 가계부 바로 사용 가능 ✅
    │                      (토큰 상태와 무관)
    No
    ↓
[Google 로그인] 또는 [나중에 로그인]
    │                      │
    ↓                      ↓
게임+가계부 사용        가계부만 사용 (게스트)
                       ⚠️ 백업 안 됨 경고 표시
```

**기능별 토큰 필요 여부:**

| 기능 | 토큰 필요? |
|------|-----------|
| 로컬 가계부 읽기/쓰기 | ❌ |
| 가계부 서버 동기화 | ✅ |
| 게임 (히어로, 자동사냥 등) | ✅ |
| 챌린지/랭킹 | ✅ |

**토큰 관리:**
```
├─ Access Token: 1시간
├─ Refresh Token: 90일
├─ 오프라인에서는 로컬 데이터 자유롭게 사용
├─ 온라인 복귀 시 토큰 자동 갱신 시도
└─ 갱신 실패 시 재로그인 요청 (가계부는 계속 사용 가능)
```

### 3.2 가계부 동기화

**상황:**
```
오프라인에서 기록:
├─ 거래 5건 기록
├─ 영수증 3장 첨부
└─ 카테고리 1개 추가

온라인 복귀 시:
└─ 서버에 백업 + 다른 기기와 동기화
```

**동기화 규칙:**
```
🎯 핵심 원칙: "Last-Write-Wins (LWW) + 로컬 생성 데이터 보존"

┌─────────────────────────────────────────────────────────────┐
│ 동기화 우선순위 (단일 규칙)                                   │
├─────────────────────────────────────────────────────────────┤
│ 1. 같은 레코드 수정 충돌 → 타임스탬프 최신 우선 (LWW)          │
│ 2. 로컬에만 존재하는 새 레코드 → 무조건 서버에 업로드           │
│ 3. 서버에만 존재하는 레코드 → 로컬로 다운로드                   │
│ 4. 삭제 충돌 → 삭제가 우선 (tombstone 마킹)                   │
└─────────────────────────────────────────────────────────────┘

⚠️ 사용자 선택 UI 없음 - 자동 해결만 (혼란 방지)

📌 Tombstone 정리 정책:
┌─────────────────────────────────────────────────────────────┐
│ 삭제된 레코드는 즉시 물리 삭제하지 않고 tombstone 마킹         │
│ (deleted_at 필드에 삭제 시간 기록)                           │
├─────────────────────────────────────────────────────────────┤
│ 정리 규칙:                                                   │
│ ├─ 삭제 후 30일 경과: 서버에서 물리 삭제                      │
│ ├─ 클라이언트: 동기화 시 서버 정책 따름                       │
│ └─ 정리 작업: 서버 배치 작업 (매일 새벽 실행)                 │
├─────────────────────────────────────────────────────────────┤
│ 복구:                                                        │
│ ├─ 30일 이내: 복구 불가 (UI 미제공, 복잡도 증가)              │
│ └─ 실수 삭제 방지: 삭제 전 확인 다이얼로그                    │
└─────────────────────────────────────────────────────────────┘
```

**동기화 전략:**
```
1️⃣ 동기화 시점
   ├─ 앱 시작 시 (온라인이면)
   ├─ WiFi 연결 시 자동
   ├─ 사용자 수동 동기화 버튼
   └─ 백그라운드 주기적 동기화

2️⃣ 동기화 순서
   ├─ 서버에서 다운로드 (다른 기기 데이터)
   ├─ 충돌 해결 (LWW)
   └─ 로컬 변경사항 업로드

3️⃣ 배치 처리
   ├─ 한 번에 최대 100건씩 전송
   ├─ 개별 레코드 단위 성공/실패 처리
   └─ 실패 건만 재시도 큐에 추가

4️⃣ 재시도 로직
   ├─ 지수 백오프: 1초 → 2초 → 4초 → 8초
   └─ 최대 10회 재시도 후 사용자 알림
```

### 3.3 게임 시스템 (온라인 전용)

**핵심:**
```
┌─────────────────────────────────────────────────────────────┐
│  게임 = 100% 서버에서 처리                                   │
│  클라이언트는 UI만 담당                                      │
│  부정행위 원천 차단                                          │
└─────────────────────────────────────────────────────────────┘
```

**⚠️ 중요: 로컬 게임 데이터 저장 금지**
```
┌─────────────────────────────────────────────────────────────┐
│  게임 데이터(히어로, 인벤토리, 경험치 등)는 로컬에 저장하지 않음  │
│  캐시 목적으로도 저장 금지 (변조 위험)                          │
│  모든 게임 상태는 서버에서 실시간 조회                          │
└─────────────────────────────────────────────────────────────┘
```

**자동사냥 처리:**
```
기존 생각 (복잡함):
└─ 오프라인에서 시간 기반 진행 → 동기화 시 검증 (부정행위 리스크)

변경 (단순함):
└─ 앱 열면 서버가 "마지막 접속 이후 시간" 계산 → 보상 지급
   ├─ 서버 시간 기준 (변조 불가능)
   ├─ 최대 24시간분 (또는 원하는 상한)
   └─ 사실상 같은 경험, 훨씬 단순

플로우:
[앱 실행] → [서버 요청: 자동사냥 결과 조회]
                ↓
         [서버 계산]
         ├─ 마지막 접속: 어제 18:00
         ├─ 현재 시간: 오늘 10:00 (16시간 경과)
         ├─ 최대 인정: 24시간
         └─ 보상: 16시간분 경험치/아이템
                ↓
         [클라이언트에 결과 전송]
                ↓
         [UI: "자동사냥 완료! 경험치 +500"]
```

**⚠️ 동시 접속 중복 보상 방지:**
```
문제: 여러 기기에서 동시 로그인 시 자동사냥 보상 중복 지급 가능

해결:
1️⃣ DB 트랜잭션 + Row Lock
   ├─ SELECT ... FOR UPDATE로 사용자 행 잠금
   ├─ 마지막 보상 수령 시간 확인
   ├─ 보상 지급 + 시간 업데이트
   └─ 커밋

2️⃣ 중복 요청 감지
   ├─ last_reward_claimed_at 컬럼 사용
   ├─ 1분 이내 재요청: 이전 결과 반환 (재지급 아님)
   └─ 클라이언트에 "이미 수령함" 응답

3️⃣ 플로우
   [기기 A 요청] → [Row Lock 획득] → [보상 지급] → [Lock 해제]
   [기기 B 요청] → [Lock 대기] → [이미 지급됨 확인] → [0 보상 반환]
```

**오프라인 시 게임 UI:**
```
[게임 탭 진입]
    ↓
[네트워크 확인] ──오프라인──→ "인터넷 연결이 필요합니다"
    │                        [가계부로 이동] 버튼
    온라인
    ↓
[게임 데이터 로드]
    ↓
[게임 플레이]
```

### 3.4 보상 시스템 (가계부 → 게임)

**상황:**
```
가계부 기록 시 게임 보상:
├─ 거래 기록 → 기본 경험치
├─ 영수증 첨부 → 추가 경험치
└─ 오프라인에서 기록해도 동기화 시 보상
```

**핵심 원칙:**
```
┌─────────────────────────────────────────────────────────────┐
│  가계부 기록: 오프라인에서 자유롭게                           │
│  보상 지급: 서버가 동기화 시점에 검증 후 지급                  │
└─────────────────────────────────────────────────────────────┘
```

**악용 방지:**
```
⚠️ 잠재적 악용:
├─ 허위 거래 대량 생성 → 보상 착취
├─ 가짜 영수증 첨부
├─ 같은 영수증 중복 등록
└─ 과거 날짜로 대량 입력

✅ 방지 방안:

1️⃣ 일일 보상 한도
   ├─ 거래 기록: 하루 최대 10건까지 보상
   ├─ 영수증: 하루 최대 5건까지 보상
   └─ 한도 초과: 기록은 저장되지만 보상 없음

2️⃣ 날짜 기반 제한
   ├─ 오늘 날짜 거래: 100% 보상
   ├─ 어제 날짜 거래: 50% 보상
   ├─ 2일 이상 과거: 보상 없음 (기록만)
   └─ 미래 날짜: 보상 없음

3️⃣ 영수증 검증 (서버)
   ├─ OCR로 날짜/금액 추출 → 거래 내역과 매칭
   ├─ 이미지 해시로 중복 감지
   └─ 검증 실패: 기본 보상만 (영수증 보상 없음)

3️⃣-1 OCR 실패 시 처리 흐름
   ├─ OCR 실패 유형:
   │   ├─ 이미지 인식 불가 (흐림, 손상)
   │   ├─ 텍스트 추출 실패
   │   └─ 날짜/금액 파싱 실패
   ├─ 처리 방식:
   │   ├─ 기본 거래 보상: 정상 지급 ✅
   │   ├─ 영수증 추가 보상: 미지급 ❌
   │   └─ 영수증 상태: "검증 실패" 마킹
   ├─ 사용자 알림:
   │   └─ "영수증 인식에 실패했습니다. 기본 보상만 지급됩니다."
   └─ 재시도:
       ├─ 사용자가 영수증 재촬영 가능
       └─ 동일 거래에 영수증 1회만 인정 (재촬영 = 교체)

4️⃣ 동기화 시 보상 처리
   ├─ 오프라인 기록 시: 보상 미지급 (대기)
   ├─ UI: "동기화 시 보상이 지급됩니다"
   ├─ 동기화 시: 서버가 검증 후 보상 계산
   └─ UI: "동기화 완료! 경험치 +150 획득"
```

**보상 플로우:**
```
[오프라인에서 거래 기록]
    ↓
[로컬 SQLite 저장]
├─ 거래 데이터 저장 ✅
├─ 영수증 이미지 저장 ✅
└─ 보상: 미지급 (pending)
    ↓
[온라인 복귀 → 동기화]
    ↓
[서버 검증]
├─ 일일 한도 체크
├─ 날짜 유효성 체크
├─ 영수증 OCR 검증
└─ 중복 체크
    ↓
[보상 계산 및 지급]
    ↓
[클라이언트에 결과 전송]
├─ 거래 3건 보상: 경험치 +90
├─ 영수증 2건 보상: 경험치 +60
└─ 총 획득: 경험치 +150
```

### 3.5 다중 기기 동기화

**가계부 동기화:**
```
🎯 핵심: 3.2의 LWW 규칙 적용

1️⃣ 기기 ID 관리
   ├─ 각 기기마다 고유 UUID 할당
   └─ 사용자 계정에 기기 목록 유지

2️⃣ 데이터 우선순위
   ├─ 타임스탬프 최신 데이터 자동 선택
   └─ 사용자 선택 UI 없음 (자동 해결)

3️⃣ 로그아웃 시
   ├─ 강제 동기화 후 로그아웃
   └─ 다른 기기에서 최신 데이터 받음
```

**게임 데이터:**
```
서버에만 저장 → 동기화 불필요 ✅
어느 기기에서든 로그인하면 같은 데이터
```

### 3.6 로컬 데이터 보안

```
1️⃣ SQLite 암호화 (필수)
   ├─ sqlcipher 또는 drift_sqflite_cipher 사용
   ├─ 암호화 키: flutter_secure_storage에 저장
   └─ 성능 영향: 약 5-15% (허용 범위)

2️⃣ 민감 데이터 분리
   ├─ 토큰: flutter_secure_storage
   ├─ 거래 데이터: 암호화된 SQLite
   └─ 캐시: 일반 저장 (OK)

3️⃣ 루팅/탈옥 감지 (선택)
   ├─ flutter_jailbreak_detection 패키지
   └─ 감지 시: 경고 표시
```

### 3.7 네트워크 불안정 대응

```
1️⃣ 오프라인 감지
   ├─ connectivity_plus 패키지
   ├─ 오프라인 시: 가계부만 활성화
   └─ 게임 탭: "인터넷 연결 필요" 표시

2️⃣ 동기화 실패 처리
   ├─ 실패 데이터: "pending" 상태로 로컬 보관
   ├─ UI: "동기화 대기 중 (3건)"
   ├─ 재연결 시 자동 재시도
   └─ 수동 동기화 버튼 제공

3️⃣ 낙관적 업데이트
   ├─ 가계부 기록: 즉시 로컬 반영
   ├─ 백그라운드에서 서버 동기화
   └─ 실패 시에도 로컬 데이터 유지
```

---

## 4. 구현 계획

### 4.1 우선순위

```
Phase 1: 가계부 오프라인
├─ SQLite 스키마 설계 (Drift) + 암호화
├─ 로컬 거래 CRUD
├─ 오프라인/온라인 상태 감지
└─ 기본 UI (가계부)

Phase 2: 인증 & 게스트
├─ Google OAuth 로그인
├─ 토큰 관리 (캐싱, 갱신)
├─ 게스트 모드 구현
└─ 로그인 유도 UI

Phase 3: 동기화
├─ 가계부 서버 백업
├─ LWW 충돌 해결
├─ 재시도 큐
└─ 다중 기기 동기화

Phase 4: 게임 연동
├─ 게임 API 연동 (온라인 전용)
├─ 자동사냥 결과 조회
├─ 보상 시스템 (가계부 → 게임)
└─ 영수증 OCR 검증

Phase 5: 마무리
├─ FCM 알림
├─ 백그라운드 동기화
├─ QA 및 버그 수정
└─ 배포
```

### 4.2 기술 스택

```
Frontend (Flutter):
├─ Riverpod (상태 관리)
├─ Drift + SQLCipher (로컬 DB + 암호화)
├─ Dio (HTTP 클라이언트)
├─ flutter_secure_storage (토큰 저장)
├─ connectivity_plus (네트워크 상태)
└─ firebase_messaging (FCM)

Backend (Go):
├─ Gin (REST API)
├─ PostgreSQL (메인 DB)
├─ Firebase Cloud Messaging
└─ Docker (배포)
```

---

## 5. 예상 효과

### Before (현재)

```
❌ 온라인 전용
❌ 가계부로 실용성 낮음
❌ 서버 부하 높음
❌ 응답 속도 느림
```

### After (개선 후)

```
✅ 가계부 완벽한 오프라인 지원
✅ 게임 부정행위 원천 차단
✅ 가계부 응답 속도 빠름 (로컬)
✅ 서버 부하 감소 (가계부 CRUD 로컬 처리)
✅ 다중 기기 동기화
✅ 명확한 구분 (오프라인 가계부 / 온라인 게임)
```

---

## 6. 위험 요소 및 대응

| 위험 | 영향도 | 대응 |
|------|--------|------|
| 가계부 동기화 복잡 | 중간 | LWW 단일 규칙, 테스트 철저 |
| 보상 악용 | 중간 | 일일 한도, 날짜 제한, 영수증 검증 |
| 오프라인 UX 혼란 | 낮음 | 명확한 상태 표시, 온보딩 |
| 로컬 데이터 유출 | 중간 | SQLite 암호화 필수 |
| 게스트 데이터 손실 | 낮음 | 로그인 유도, 경고 표시 |

---

## 7. 추가 고려 사항

### 7.1 게스트 → 로그인 데이터 병합 정책

```
게스트 상태에서 로그인 시:

1️⃣ 신규 계정 (서버에 데이터 없음)
   └─ 게스트 데이터 → 새 계정에 연결
   └─ 자동 처리, 사용자 선택 불필요

2️⃣ 기존 계정 (서버에 데이터 있음)
   ├─ 사용자에게 선택 UI 표시:
   │   ├─ "이 기기 데이터 유지" → 서버 덮어쓰기
   │   └─ "기존 데이터 가져오기" → 게스트 데이터 삭제
   └─ 병합(merge)은 지원하지 않음 (복잡도 증가)

⚠️ 주의사항:
├─ 선택 전 각 옵션의 데이터 개수 표시
│   예: "이 기기: 거래 15건 / 서버: 거래 42건"
├─ 되돌릴 수 없음 경고 필수
└─ 선택 후 즉시 동기화 실행

플로우:
[게스트 상태] → [로그인 시도]
                    ↓
            [서버 데이터 확인]
                    ↓
        ┌─────────┴─────────┐
    데이터 없음           데이터 있음
        ↓                    ↓
    자동 연결            [선택 UI 표시]
        ↓                    ↓
    [동기화]        [사용자 선택 대기]
                            ↓
                    [선택에 따라 처리]
                            ↓
                        [동기화]
```

### 7.2 스토리지 한계

```
로컬 DB 예상 크기:
├─ 거래 1건: ~200 bytes
├─ 1년 거래 (1000건): ~200 KB
├─ 총 예상: 1MB 미만 (대부분 사용자)
└─ 문제 없음 ✅
```

### 7.3 테스트 시나리오

```
1️⃣ 오프라인 테스트
   ├─ 가계부 CRUD (오프라인)
   ├─ 온라인 전환 시 동기화
   └─ 게임 탭 접근 차단 확인

2️⃣ 동기화 테스트
   ├─ 다중 기기 충돌 해결
   ├─ 네트워크 불안정 시뮬레이션
   └─ 대량 데이터 동기화

3️⃣ 보상 테스트
   ├─ 일일 한도 초과
   ├─ 과거 날짜 거래
   └─ 영수증 중복 감지
```

---

## 8. 결론

**하이브리드 아키텍처:**
- 가계부: 오프라인 완전 지원
- 게임: 온라인 전용

**장점:**
- 복잡도 대폭 감소 (게임 동기화 불필요)
- 부정행위 원천 차단 (게임은 서버에서 처리)
- 가계부 핵심 가치 유지 (언제 어디서나 기록)
- 명확한 사용자 경험

**핵심 원칙 요약:**
- 로그인 = 동기화/게임 활성화 (앱 사용 권한 아님)
- 가계부 동기화: **LWW (Last-Write-Wins)** 자동 해결
- 보상 지급: **서버 검증 후 지급** (일일 한도, 날짜 제한)
- 보안: **SQLite 암호화** 필수
